Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.

 

Example 1:

Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]

Example 2:

Input: nums = [0]
Output: [0]
 

Constraints:

1 <= nums.length <= 104
-231 <= nums[i] <= 231 - 1
 








=========================================






Answer


Approach : 

We can use two pointers:
insertPos → keeps track of where the next non-zero element should go.
Iterate through nums:
For every non-zero element, assign it to nums[insertPos] and increment insertPos.
After moving all non-zero elements, fill the rest of the array with zeros.
This approach is efficient, clean, and uses no extra space.

This yields O(n) time(single pass + filling zeros) and O(1) space complexity(in-place)


Code snippet :

class Solution {
    public void moveZeroes(int[] nums) {
        int insertnonzeroes=0;
        for (int num : nums) {
            if (num != 0) {
                nums[insertnonzeroes++] = num;
            }
        }
        while (insertnonzeroes < nums.length) {
            nums[insertnonzeroes++] = 0;
        }
    }
}

Alternate swap solution:

class Solution {
    public void moveZeroes(int[] nums) {
        int lastNonZero = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                int temp = nums[i];
                nums[i] = nums[lastNonZero];
                nums[lastNonZero] = temp;
                lastNonZero++;
            }
        }
    }
}





Q1. Which version is better?

The swap version is more compact (single pass).
The two-phase version (first move non-zeros, then fill zeros) does fewer writes → better when minimizing memory operations is preferred.